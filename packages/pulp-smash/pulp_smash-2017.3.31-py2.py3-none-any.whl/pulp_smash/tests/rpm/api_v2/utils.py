# coding=utf-8
"""Utility functions for RPM API tests."""
import gzip
import io
from os.path import basename
from urllib.parse import urljoin
from xml.etree import ElementTree

from pulp_smash import api, cli, selectors, utils
from pulp_smash.constants import RPM_NAMESPACES


def gen_repo():
    """Return a semi-random dict for use in creating an RPM repository."""
    return {
        'id': utils.uuid4(),
        'importer_config': {},
        'importer_type_id': 'yum_importer',
        'notes': {'_repo-type': 'rpm-repo'},
    }


def gen_repo_group():
    """Return a semi-random dict for use in creating a RPM repository group."""
    return {
        'id': utils.uuid4(),
    }


def gen_distributor():
    """Return a semi-random dict for use in creating a YUM distributor."""
    return {
        'auto_publish': False,
        'distributor_id': utils.uuid4(),
        'distributor_type_id': 'yum_distributor',
        'distributor_config': {
            'http': True,
            'https': True,
            'relative_url': utils.uuid4() + '/',
        },
    }


def get_repodata_repomd_xml(cfg, distributor, response_handler=None):
    """Download the given repository's ``repodata/repomd.xml`` file.

    :param pulp_smash.config.ServerConfig cfg: Information about a Pulp host.
    :param distributor: A dict of information about a repository distributor.
    :param response_handler: The callback function used by
        :class:`pulp_smash.api.Client` after downloading the ``repomd.xml``
        file. Defaults to :func:`xml_handler`. Use
        :func:`pulp_smash.api.safe_handler` if you want the raw response.
    :returns: Whatever is dictated by ``response_handler``.
    """
    path = urljoin('/pulp/repos/', distributor['config']['relative_url'])
    if not path.endswith('/'):
        path += '/'
    path = urljoin(path, 'repodata/repomd.xml')
    if response_handler is None:
        response_handler = xml_handler
    return api.Client(cfg, response_handler).get(path)


def get_repodata(
        cfg,
        distributor,
        type_,
        response_handler=None,
        repomd_xml=None):
    """Download a file of the given ``type_`` from a ``repodata/`` directory.

    :param pulp_smash.config.ServerConfig cfg: Information about a Pulp host.
    :param distributor: A dict of information about a repository distributor.
    :param type_: The type of file to fetch from a repository's ``repodata/``
        directory. Valid values might be "updateinfo" or "group".
    :param response_handler: The callback function used by
        :class:`pulp_smash.api.Client` after downloading the ``repomd.xml``
        file. Defaults to :func:`xml_handler`. Use
        :func:`pulp_smash.api.safe_handler` if you want the raw response.
    :param repomd_xml: A ``repomd.xml`` file as an ``ElementTree``. If not
        given, :func:`get_repodata_repomd_xml` is consulted.
    :returns: Whatever is dictated by ``response_handler``.
    """
    # Download and search through ``.../repodata/repomd.xml``.
    if repomd_xml is None:
        repomd_xml = get_repodata_repomd_xml(cfg, distributor)
    xpath = (
        "{{{namespace}}}data[@type='{type_}']/{{{namespace}}}location"
        .format(namespace=RPM_NAMESPACES['metadata/repo'], type_=type_)
    )
    location_elements = repomd_xml.findall(xpath)
    if len(location_elements) != 1:
        raise ValueError(
            'The given "repomd.xml" file should contain one matching '
            '"location" element, but {} were found with the XPath selector {}'
            .format(len(location_elements), xpath)
        )

    # Build the URL to the file of the requested `type_`.
    path = urljoin('/pulp/repos/', distributor['config']['relative_url'])
    if not path.endswith('/'):
        path += '/'
    path = urljoin(path, location_elements[0].get('href'))
    if response_handler is None:
        response_handler = xml_handler
    return api.Client(cfg, response_handler).get(path)


def xml_handler(_, response):
    """API response handler for fetching XML generated by yum distributor.

    Check the status code of ``response``, decompress the response if the
    request URL ended in ``.gz``, and return an ``xml.etree.Element`` instance
    built from the response body.

    Note:

    * The entire response XML is loaded and parsed before returning, so this
      may be unsafe for use with large XML files.
    * The ``Content-Type`` and ``Content-Encoding`` response headers are
      ignored due to https://pulp.plan.io/issues/1781.
    """
    response.raise_for_status()
    if response.request.url.endswith('.gz'):  # See bug referenced in docstring
        with io.BytesIO(response.content) as compressed:
            with gzip.GzipFile(fileobj=compressed) as decompressed:
                xml_bytes = decompressed.read()
    else:
        xml_bytes = response.content
    # A well-formed XML document begins with a declaration like this:
    #
    #     <?xml version="1.0" encoding="UTF-8"?>
    #
    # We are trusting the parser to handle this correctly.
    return ElementTree.fromstring(xml_bytes)


class DisableSELinuxMixin(object):  # pylint:disable=too-few-public-methods
    """A mixin providing the ability to temporarily disable SELinux."""

    def maybe_disable_selinux(self, cfg, pulp_issue_id):
        """Disable SELinux if appropriate.

        If the given Pulp issue is unresolved, and if SELinux is installed and
        enforcing on the target Pulp system, then disable SELinux and schedule
        it to be re-enabled. (Method ``addCleanup`` is used for the schedule.)

        :param pulp_smash.config.ServerConfig cfg: Information about the Pulp
            server being targeted.
        :param pulp_issue_id: The (integer) ID of a `Pulp issue`_. If the
            referenced issue is fixed in the Pulp system under test, this
            method immediately returns.
        :returns: Nothing.

        .. _Pulp issue: https://pulp.plan.io/issues/
        """
        # Abort if the Pulp issue is resolved, if SELinux is not installed or
        # if SELinux is not enforcing.
        #
        # NOTE: Hard-coding the absolute path to a command is a Bad Ideaâ„¢.
        # However, non-login non-root shells may have short PATH environment
        # variables. For example:
        #
        #     /usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin
        #
        # We cannot execute `PATH=${PATH}:/usr/sbin which getenforce` because
        # Plumbum does a good job of preventing shell expansions. See:
        # https://github.com/PulpQE/pulp-smash/issues/89
        if selectors.bug_is_testable(pulp_issue_id, cfg.version):
            return
        client = cli.Client(cfg, cli.echo_handler)
        cmd = 'test -e /usr/sbin/getenforce'.split()
        if client.run(cmd).returncode != 0:
            return
        client.response_handler = cli.code_handler
        cmd = ['/usr/sbin/getenforce']
        if client.run(cmd).stdout.strip().lower() != 'enforcing':
            return

        # Temporarily disable SELinux.
        sudo = '' if utils.is_root(cfg) else 'sudo '
        cmd = (sudo + 'setenforce 0').split()
        client.run(cmd)
        cmd = (sudo + 'setenforce 1').split()
        self.addCleanup(client.run, cmd)


def get_unit(cfg, distributor, unit_name, primary_xml=None):
    """Download a file from a published repository.

    A typical invocation is as follows:

        >>> foo_rpm = get_unit(cfg, repo['distributors'][0], 'foo.rpm')

    If multiple units are being fetched, efficiency can be improved by passing
    in a parsed ``primary.xml`` file:

        >>> distributor = repo['distributors'][0]
        >>> primary_xml = get_repodata(cfg, distributor, 'primary')
        >>> foo_rpm = get_unit(cfg, distributor, 'foo.rpm', primary_xml)
        >>> bar_rpm = get_unit(cfg, distributor, 'bar.rpm', primary_xml)

    :param pulp_smash.config.ServerConfig cfg: Information about a Pulp host.
    :param distributor: A dict of information about a repository distributor.
    :param unit_name: The name of a content unit to be fetched. For example:
        "bear-4.1-1.noarch.rpm".
    :param primary_xml: A ``primary.xml`` file as an ``ElementTree``. If not
        given, :func:`get_repodata` is consulted.
    :returns: A raw response. The unit is available as ``response.content``.
    """
    if primary_xml is None:
        primary_xml = get_repodata(cfg, distributor, 'primary')

    # Create a dict in the form {foo.rpm: Packages/f/foo.rpm}
    xpath = '{{{}}}package'.format(RPM_NAMESPACES['metadata/common'])
    packages = primary_xml.findall(xpath)
    xpath = '{{{}}}location'.format(RPM_NAMESPACES['metadata/common'])
    hrefs = [package.find(xpath).get('href') for package in packages]
    href_map = {basename(href): href for href in hrefs}
    href = href_map[unit_name]

    # Fetch the unit.
    path = urljoin('/pulp/repos/', distributor['config']['relative_url'])
    if not path.endswith('/'):
        path += '/'
    path = urljoin(path, href)
    return api.Client(cfg).get(path)
