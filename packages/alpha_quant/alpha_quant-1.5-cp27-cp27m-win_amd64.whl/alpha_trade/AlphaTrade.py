#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def Running(self):
    pass

  def GetPID(self):
    pass

  def LiveTradeLogin(self, sessionID, account, password1, password2, brokerStr):
    """
    Parameters:
     - sessionID
     - account
     - password1
     - password2
     - brokerStr
    """
    pass

  def LiveTradeLogout(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    pass

  def GetAccountState(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    pass

  def GetAccountBalance(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    pass

  def GetHoldingStock(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    pass

  def GetOrderState(self, sessionID, liveTradeID, orderID):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - orderID
    """
    pass

  def CloseOrder(self, sessionID, liveTradeID, orderID):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - orderID
    """
    pass

  def LiveTradeBuy(self, sessionID, liveTradeID, sid, price, quant, orderType):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
    """
    pass

  def LiveTradeBuyClose(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
     - closeToday
    """
    pass

  def LiveTradeSell(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
     - closeToday
    """
    pass

  def LiveTradeSellOpen(self, sessionID, liveTradeID, sid, price, quant, orderType):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def Running(self):
    self.send_Running()
    return self.recv_Running()

  def send_Running(self):
    self._oprot.writeMessageBegin('Running', TMessageType.CALL, self._seqid)
    args = Running_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_Running(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = Running_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "Running failed: unknown result")

  def GetPID(self):
    self.send_GetPID()
    return self.recv_GetPID()

  def send_GetPID(self):
    self._oprot.writeMessageBegin('GetPID', TMessageType.CALL, self._seqid)
    args = GetPID_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetPID(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetPID_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPID failed: unknown result")

  def LiveTradeLogin(self, sessionID, account, password1, password2, brokerStr):
    """
    Parameters:
     - sessionID
     - account
     - password1
     - password2
     - brokerStr
    """
    self.send_LiveTradeLogin(sessionID, account, password1, password2, brokerStr)
    return self.recv_LiveTradeLogin()

  def send_LiveTradeLogin(self, sessionID, account, password1, password2, brokerStr):
    self._oprot.writeMessageBegin('LiveTradeLogin', TMessageType.CALL, self._seqid)
    args = LiveTradeLogin_args()
    args.sessionID = sessionID
    args.account = account
    args.password1 = password1
    args.password2 = password2
    args.brokerStr = brokerStr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeLogin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeLogin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeLogin failed: unknown result")

  def LiveTradeLogout(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    self.send_LiveTradeLogout(sessionID, liveTradeID)
    return self.recv_LiveTradeLogout()

  def send_LiveTradeLogout(self, sessionID, liveTradeID):
    self._oprot.writeMessageBegin('LiveTradeLogout', TMessageType.CALL, self._seqid)
    args = LiveTradeLogout_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeLogout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeLogout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeLogout failed: unknown result")

  def GetAccountState(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    self.send_GetAccountState(sessionID, liveTradeID)
    return self.recv_GetAccountState()

  def send_GetAccountState(self, sessionID, liveTradeID):
    self._oprot.writeMessageBegin('GetAccountState', TMessageType.CALL, self._seqid)
    args = GetAccountState_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAccountState(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetAccountState_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAccountState failed: unknown result")

  def GetAccountBalance(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    self.send_GetAccountBalance(sessionID, liveTradeID)
    return self.recv_GetAccountBalance()

  def send_GetAccountBalance(self, sessionID, liveTradeID):
    self._oprot.writeMessageBegin('GetAccountBalance', TMessageType.CALL, self._seqid)
    args = GetAccountBalance_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAccountBalance(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetAccountBalance_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAccountBalance failed: unknown result")

  def GetHoldingStock(self, sessionID, liveTradeID):
    """
    Parameters:
     - sessionID
     - liveTradeID
    """
    self.send_GetHoldingStock(sessionID, liveTradeID)
    return self.recv_GetHoldingStock()

  def send_GetHoldingStock(self, sessionID, liveTradeID):
    self._oprot.writeMessageBegin('GetHoldingStock', TMessageType.CALL, self._seqid)
    args = GetHoldingStock_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetHoldingStock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetHoldingStock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHoldingStock failed: unknown result")

  def GetOrderState(self, sessionID, liveTradeID, orderID):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - orderID
    """
    self.send_GetOrderState(sessionID, liveTradeID, orderID)
    return self.recv_GetOrderState()

  def send_GetOrderState(self, sessionID, liveTradeID, orderID):
    self._oprot.writeMessageBegin('GetOrderState', TMessageType.CALL, self._seqid)
    args = GetOrderState_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.orderID = orderID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetOrderState(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetOrderState_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetOrderState failed: unknown result")

  def CloseOrder(self, sessionID, liveTradeID, orderID):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - orderID
    """
    self.send_CloseOrder(sessionID, liveTradeID, orderID)
    return self.recv_CloseOrder()

  def send_CloseOrder(self, sessionID, liveTradeID, orderID):
    self._oprot.writeMessageBegin('CloseOrder', TMessageType.CALL, self._seqid)
    args = CloseOrder_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.orderID = orderID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CloseOrder(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CloseOrder_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CloseOrder failed: unknown result")

  def LiveTradeBuy(self, sessionID, liveTradeID, sid, price, quant, orderType):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
    """
    self.send_LiveTradeBuy(sessionID, liveTradeID, sid, price, quant, orderType)
    return self.recv_LiveTradeBuy()

  def send_LiveTradeBuy(self, sessionID, liveTradeID, sid, price, quant, orderType):
    self._oprot.writeMessageBegin('LiveTradeBuy', TMessageType.CALL, self._seqid)
    args = LiveTradeBuy_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.sid = sid
    args.price = price
    args.quant = quant
    args.orderType = orderType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeBuy(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeBuy_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeBuy failed: unknown result")

  def LiveTradeBuyClose(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
     - closeToday
    """
    self.send_LiveTradeBuyClose(sessionID, liveTradeID, sid, price, quant, orderType, closeToday)
    return self.recv_LiveTradeBuyClose()

  def send_LiveTradeBuyClose(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    self._oprot.writeMessageBegin('LiveTradeBuyClose', TMessageType.CALL, self._seqid)
    args = LiveTradeBuyClose_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.sid = sid
    args.price = price
    args.quant = quant
    args.orderType = orderType
    args.closeToday = closeToday
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeBuyClose(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeBuyClose_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeBuyClose failed: unknown result")

  def LiveTradeSell(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
     - closeToday
    """
    self.send_LiveTradeSell(sessionID, liveTradeID, sid, price, quant, orderType, closeToday)
    return self.recv_LiveTradeSell()

  def send_LiveTradeSell(self, sessionID, liveTradeID, sid, price, quant, orderType, closeToday):
    self._oprot.writeMessageBegin('LiveTradeSell', TMessageType.CALL, self._seqid)
    args = LiveTradeSell_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.sid = sid
    args.price = price
    args.quant = quant
    args.orderType = orderType
    args.closeToday = closeToday
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeSell(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeSell_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeSell failed: unknown result")

  def LiveTradeSellOpen(self, sessionID, liveTradeID, sid, price, quant, orderType):
    """
    Parameters:
     - sessionID
     - liveTradeID
     - sid
     - price
     - quant
     - orderType
    """
    self.send_LiveTradeSellOpen(sessionID, liveTradeID, sid, price, quant, orderType)
    return self.recv_LiveTradeSellOpen()

  def send_LiveTradeSellOpen(self, sessionID, liveTradeID, sid, price, quant, orderType):
    self._oprot.writeMessageBegin('LiveTradeSellOpen', TMessageType.CALL, self._seqid)
    args = LiveTradeSellOpen_args()
    args.sessionID = sessionID
    args.liveTradeID = liveTradeID
    args.sid = sid
    args.price = price
    args.quant = quant
    args.orderType = orderType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LiveTradeSellOpen(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LiveTradeSellOpen_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LiveTradeSellOpen failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["Running"] = Processor.process_Running
    self._processMap["GetPID"] = Processor.process_GetPID
    self._processMap["LiveTradeLogin"] = Processor.process_LiveTradeLogin
    self._processMap["LiveTradeLogout"] = Processor.process_LiveTradeLogout
    self._processMap["GetAccountState"] = Processor.process_GetAccountState
    self._processMap["GetAccountBalance"] = Processor.process_GetAccountBalance
    self._processMap["GetHoldingStock"] = Processor.process_GetHoldingStock
    self._processMap["GetOrderState"] = Processor.process_GetOrderState
    self._processMap["CloseOrder"] = Processor.process_CloseOrder
    self._processMap["LiveTradeBuy"] = Processor.process_LiveTradeBuy
    self._processMap["LiveTradeBuyClose"] = Processor.process_LiveTradeBuyClose
    self._processMap["LiveTradeSell"] = Processor.process_LiveTradeSell
    self._processMap["LiveTradeSellOpen"] = Processor.process_LiveTradeSellOpen

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_Running(self, seqid, iprot, oprot):
    args = Running_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Running_result()
    try:
      result.success = self._handler.Running()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("Running", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetPID(self, seqid, iprot, oprot):
    args = GetPID_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetPID_result()
    try:
      result.success = self._handler.GetPID()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetPID", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeLogin(self, seqid, iprot, oprot):
    args = LiveTradeLogin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeLogin_result()
    try:
      result.success = self._handler.LiveTradeLogin(args.sessionID, args.account, args.password1, args.password2, args.brokerStr)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeLogin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeLogout(self, seqid, iprot, oprot):
    args = LiveTradeLogout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeLogout_result()
    try:
      result.success = self._handler.LiveTradeLogout(args.sessionID, args.liveTradeID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeLogout", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAccountState(self, seqid, iprot, oprot):
    args = GetAccountState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAccountState_result()
    try:
      result.success = self._handler.GetAccountState(args.sessionID, args.liveTradeID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetAccountState", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAccountBalance(self, seqid, iprot, oprot):
    args = GetAccountBalance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAccountBalance_result()
    try:
      result.success = self._handler.GetAccountBalance(args.sessionID, args.liveTradeID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetAccountBalance", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetHoldingStock(self, seqid, iprot, oprot):
    args = GetHoldingStock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetHoldingStock_result()
    try:
      result.success = self._handler.GetHoldingStock(args.sessionID, args.liveTradeID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetHoldingStock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetOrderState(self, seqid, iprot, oprot):
    args = GetOrderState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetOrderState_result()
    try:
      result.success = self._handler.GetOrderState(args.sessionID, args.liveTradeID, args.orderID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetOrderState", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CloseOrder(self, seqid, iprot, oprot):
    args = CloseOrder_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CloseOrder_result()
    try:
      result.success = self._handler.CloseOrder(args.sessionID, args.liveTradeID, args.orderID)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("CloseOrder", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeBuy(self, seqid, iprot, oprot):
    args = LiveTradeBuy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeBuy_result()
    try:
      result.success = self._handler.LiveTradeBuy(args.sessionID, args.liveTradeID, args.sid, args.price, args.quant, args.orderType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeBuy", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeBuyClose(self, seqid, iprot, oprot):
    args = LiveTradeBuyClose_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeBuyClose_result()
    try:
      result.success = self._handler.LiveTradeBuyClose(args.sessionID, args.liveTradeID, args.sid, args.price, args.quant, args.orderType, args.closeToday)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeBuyClose", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeSell(self, seqid, iprot, oprot):
    args = LiveTradeSell_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeSell_result()
    try:
      result.success = self._handler.LiveTradeSell(args.sessionID, args.liveTradeID, args.sid, args.price, args.quant, args.orderType, args.closeToday)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeSell", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LiveTradeSellOpen(self, seqid, iprot, oprot):
    args = LiveTradeSellOpen_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LiveTradeSellOpen_result()
    try:
      result.success = self._handler.LiveTradeSellOpen(args.sessionID, args.liveTradeID, args.sid, args.price, args.quant, args.orderType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LiveTradeSellOpen", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class Running_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Running_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Running_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Running_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPID_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPID_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPID_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPID_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeLogin_args:
  """
  Attributes:
   - sessionID
   - account
   - password1
   - password2
   - brokerStr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'account', None, None, ), # 2
    (3, TType.STRING, 'password1', None, None, ), # 3
    (4, TType.STRING, 'password2', None, None, ), # 4
    (5, TType.STRING, 'brokerStr', None, None, ), # 5
  )

  def __init__(self, sessionID=None, account=None, password1=None, password2=None, brokerStr=None,):
    self.sessionID = sessionID
    self.account = account
    self.password1 = password1
    self.password2 = password2
    self.brokerStr = brokerStr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.password1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.password2 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.brokerStr = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeLogin_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.account is not None:
      oprot.writeFieldBegin('account', TType.STRING, 2)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.password1 is not None:
      oprot.writeFieldBegin('password1', TType.STRING, 3)
      oprot.writeString(self.password1)
      oprot.writeFieldEnd()
    if self.password2 is not None:
      oprot.writeFieldBegin('password2', TType.STRING, 4)
      oprot.writeString(self.password2)
      oprot.writeFieldEnd()
    if self.brokerStr is not None:
      oprot.writeFieldBegin('brokerStr', TType.STRING, 5)
      oprot.writeString(self.brokerStr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.account)
    value = (value * 31) ^ hash(self.password1)
    value = (value * 31) ^ hash(self.password2)
    value = (value * 31) ^ hash(self.brokerStr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeLogin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LiveTradeLoginResp, LiveTradeLoginResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LiveTradeLoginResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeLogin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeLogout_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
  )

  def __init__(self, sessionID=None, liveTradeID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeLogout_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeLogout_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LiveTradeLogoutResp, LiveTradeLogoutResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LiveTradeLogoutResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeLogout_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAccountState_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
  )

  def __init__(self, sessionID=None, liveTradeID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAccountState_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAccountState_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAccountStateResp, GetAccountStateResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAccountStateResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAccountState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAccountBalance_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
  )

  def __init__(self, sessionID=None, liveTradeID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAccountBalance_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAccountBalance_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAccountBalanceResp, GetAccountBalanceResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAccountBalanceResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAccountBalance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetHoldingStock_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
  )

  def __init__(self, sessionID=None, liveTradeID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetHoldingStock_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetHoldingStock_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetHoldingStockResp, GetHoldingStockResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetHoldingStockResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetHoldingStock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOrderState_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - orderID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'orderID', None, None, ), # 3
  )

  def __init__(self, sessionID=None, liveTradeID=None, orderID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.orderID = orderID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.orderID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOrderState_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.orderID is not None:
      oprot.writeFieldBegin('orderID', TType.STRING, 3)
      oprot.writeString(self.orderID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.orderID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOrderState_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetOrderStateResp, GetOrderStateResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetOrderStateResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOrderState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CloseOrder_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - orderID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'orderID', None, None, ), # 3
  )

  def __init__(self, sessionID=None, liveTradeID=None, orderID=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.orderID = orderID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.orderID = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CloseOrder_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.orderID is not None:
      oprot.writeFieldBegin('orderID', TType.STRING, 3)
      oprot.writeString(self.orderID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.orderID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CloseOrder_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CloseOrderResp, CloseOrderResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CloseOrderResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CloseOrder_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeBuy_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - sid
   - price
   - quant
   - orderType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'sid', None, None, ), # 3
    (4, TType.DOUBLE, 'price', None, None, ), # 4
    (5, TType.DOUBLE, 'quant', None, None, ), # 5
    (6, TType.STRING, 'orderType', None, None, ), # 6
  )

  def __init__(self, sessionID=None, liveTradeID=None, sid=None, price=None, quant=None, orderType=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.sid = sid
    self.price = price
    self.quant = quant
    self.orderType = orderType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.price = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.quant = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.orderType = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeBuy_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.sid is not None:
      oprot.writeFieldBegin('sid', TType.STRING, 3)
      oprot.writeString(self.sid)
      oprot.writeFieldEnd()
    if self.price is not None:
      oprot.writeFieldBegin('price', TType.DOUBLE, 4)
      oprot.writeDouble(self.price)
      oprot.writeFieldEnd()
    if self.quant is not None:
      oprot.writeFieldBegin('quant', TType.DOUBLE, 5)
      oprot.writeDouble(self.quant)
      oprot.writeFieldEnd()
    if self.orderType is not None:
      oprot.writeFieldBegin('orderType', TType.STRING, 6)
      oprot.writeString(self.orderType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.sid)
    value = (value * 31) ^ hash(self.price)
    value = (value * 31) ^ hash(self.quant)
    value = (value * 31) ^ hash(self.orderType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeBuy_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PlaceOrderResp, PlaceOrderResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PlaceOrderResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeBuy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeBuyClose_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - sid
   - price
   - quant
   - orderType
   - closeToday
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'sid', None, None, ), # 3
    (4, TType.DOUBLE, 'price', None, None, ), # 4
    (5, TType.DOUBLE, 'quant', None, None, ), # 5
    (6, TType.STRING, 'orderType', None, None, ), # 6
    (7, TType.BOOL, 'closeToday', None, None, ), # 7
  )

  def __init__(self, sessionID=None, liveTradeID=None, sid=None, price=None, quant=None, orderType=None, closeToday=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.sid = sid
    self.price = price
    self.quant = quant
    self.orderType = orderType
    self.closeToday = closeToday

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.price = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.quant = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.orderType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.closeToday = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeBuyClose_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.sid is not None:
      oprot.writeFieldBegin('sid', TType.STRING, 3)
      oprot.writeString(self.sid)
      oprot.writeFieldEnd()
    if self.price is not None:
      oprot.writeFieldBegin('price', TType.DOUBLE, 4)
      oprot.writeDouble(self.price)
      oprot.writeFieldEnd()
    if self.quant is not None:
      oprot.writeFieldBegin('quant', TType.DOUBLE, 5)
      oprot.writeDouble(self.quant)
      oprot.writeFieldEnd()
    if self.orderType is not None:
      oprot.writeFieldBegin('orderType', TType.STRING, 6)
      oprot.writeString(self.orderType)
      oprot.writeFieldEnd()
    if self.closeToday is not None:
      oprot.writeFieldBegin('closeToday', TType.BOOL, 7)
      oprot.writeBool(self.closeToday)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.sid)
    value = (value * 31) ^ hash(self.price)
    value = (value * 31) ^ hash(self.quant)
    value = (value * 31) ^ hash(self.orderType)
    value = (value * 31) ^ hash(self.closeToday)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeBuyClose_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PlaceOrderResp, PlaceOrderResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PlaceOrderResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeBuyClose_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeSell_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - sid
   - price
   - quant
   - orderType
   - closeToday
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'sid', None, None, ), # 3
    (4, TType.DOUBLE, 'price', None, None, ), # 4
    (5, TType.DOUBLE, 'quant', None, None, ), # 5
    (6, TType.STRING, 'orderType', None, None, ), # 6
    (7, TType.BOOL, 'closeToday', None, None, ), # 7
  )

  def __init__(self, sessionID=None, liveTradeID=None, sid=None, price=None, quant=None, orderType=None, closeToday=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.sid = sid
    self.price = price
    self.quant = quant
    self.orderType = orderType
    self.closeToday = closeToday

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.price = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.quant = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.orderType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.closeToday = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeSell_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.sid is not None:
      oprot.writeFieldBegin('sid', TType.STRING, 3)
      oprot.writeString(self.sid)
      oprot.writeFieldEnd()
    if self.price is not None:
      oprot.writeFieldBegin('price', TType.DOUBLE, 4)
      oprot.writeDouble(self.price)
      oprot.writeFieldEnd()
    if self.quant is not None:
      oprot.writeFieldBegin('quant', TType.DOUBLE, 5)
      oprot.writeDouble(self.quant)
      oprot.writeFieldEnd()
    if self.orderType is not None:
      oprot.writeFieldBegin('orderType', TType.STRING, 6)
      oprot.writeString(self.orderType)
      oprot.writeFieldEnd()
    if self.closeToday is not None:
      oprot.writeFieldBegin('closeToday', TType.BOOL, 7)
      oprot.writeBool(self.closeToday)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.sid)
    value = (value * 31) ^ hash(self.price)
    value = (value * 31) ^ hash(self.quant)
    value = (value * 31) ^ hash(self.orderType)
    value = (value * 31) ^ hash(self.closeToday)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeSell_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PlaceOrderResp, PlaceOrderResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PlaceOrderResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeSell_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeSellOpen_args:
  """
  Attributes:
   - sessionID
   - liveTradeID
   - sid
   - price
   - quant
   - orderType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionID', None, None, ), # 1
    (2, TType.STRING, 'liveTradeID', None, None, ), # 2
    (3, TType.STRING, 'sid', None, None, ), # 3
    (4, TType.DOUBLE, 'price', None, None, ), # 4
    (5, TType.DOUBLE, 'quant', None, None, ), # 5
    (6, TType.STRING, 'orderType', None, None, ), # 6
  )

  def __init__(self, sessionID=None, liveTradeID=None, sid=None, price=None, quant=None, orderType=None,):
    self.sessionID = sessionID
    self.liveTradeID = liveTradeID
    self.sid = sid
    self.price = price
    self.quant = quant
    self.orderType = orderType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.liveTradeID = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.price = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.quant = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.orderType = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeSellOpen_args')
    if self.sessionID is not None:
      oprot.writeFieldBegin('sessionID', TType.STRING, 1)
      oprot.writeString(self.sessionID)
      oprot.writeFieldEnd()
    if self.liveTradeID is not None:
      oprot.writeFieldBegin('liveTradeID', TType.STRING, 2)
      oprot.writeString(self.liveTradeID)
      oprot.writeFieldEnd()
    if self.sid is not None:
      oprot.writeFieldBegin('sid', TType.STRING, 3)
      oprot.writeString(self.sid)
      oprot.writeFieldEnd()
    if self.price is not None:
      oprot.writeFieldBegin('price', TType.DOUBLE, 4)
      oprot.writeDouble(self.price)
      oprot.writeFieldEnd()
    if self.quant is not None:
      oprot.writeFieldBegin('quant', TType.DOUBLE, 5)
      oprot.writeDouble(self.quant)
      oprot.writeFieldEnd()
    if self.orderType is not None:
      oprot.writeFieldBegin('orderType', TType.STRING, 6)
      oprot.writeString(self.orderType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sessionID)
    value = (value * 31) ^ hash(self.liveTradeID)
    value = (value * 31) ^ hash(self.sid)
    value = (value * 31) ^ hash(self.price)
    value = (value * 31) ^ hash(self.quant)
    value = (value * 31) ^ hash(self.orderType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LiveTradeSellOpen_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PlaceOrderResp, PlaceOrderResp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PlaceOrderResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LiveTradeSellOpen_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
