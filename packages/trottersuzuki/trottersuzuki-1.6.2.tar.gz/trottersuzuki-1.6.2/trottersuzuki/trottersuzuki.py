# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_trottersuzuki', [dirname(__file__)])
        except ImportError:
            import _trottersuzuki
            return _trottersuzuki
        if fp is not None:
            try:
                _mod = imp.load_module('_trottersuzuki', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _trottersuzuki = swig_import_helper()
    del swig_import_helper
else:
    import _trottersuzuki
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class Lattice(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice, name)
    __repr__ = _swig_repr
    __swig_setmethods__["length_x"] = _trottersuzuki.Lattice_length_x_set
    __swig_getmethods__["length_x"] = _trottersuzuki.Lattice_length_x_get
    if _newclass:
        length_x = _swig_property(_trottersuzuki.Lattice_length_x_get, _trottersuzuki.Lattice_length_x_set)
    __swig_setmethods__["length_y"] = _trottersuzuki.Lattice_length_y_set
    __swig_getmethods__["length_y"] = _trottersuzuki.Lattice_length_y_get
    if _newclass:
        length_y = _swig_property(_trottersuzuki.Lattice_length_y_get, _trottersuzuki.Lattice_length_y_set)
    __swig_setmethods__["delta_x"] = _trottersuzuki.Lattice_delta_x_set
    __swig_getmethods__["delta_x"] = _trottersuzuki.Lattice_delta_x_get
    if _newclass:
        delta_x = _swig_property(_trottersuzuki.Lattice_delta_x_get, _trottersuzuki.Lattice_delta_x_set)
    __swig_setmethods__["delta_y"] = _trottersuzuki.Lattice_delta_y_set
    __swig_getmethods__["delta_y"] = _trottersuzuki.Lattice_delta_y_get
    if _newclass:
        delta_y = _swig_property(_trottersuzuki.Lattice_delta_y_get, _trottersuzuki.Lattice_delta_y_set)
    __swig_setmethods__["dim_x"] = _trottersuzuki.Lattice_dim_x_set
    __swig_getmethods__["dim_x"] = _trottersuzuki.Lattice_dim_x_get
    if _newclass:
        dim_x = _swig_property(_trottersuzuki.Lattice_dim_x_get, _trottersuzuki.Lattice_dim_x_set)
    __swig_setmethods__["dim_y"] = _trottersuzuki.Lattice_dim_y_set
    __swig_getmethods__["dim_y"] = _trottersuzuki.Lattice_dim_y_get
    if _newclass:
        dim_y = _swig_property(_trottersuzuki.Lattice_dim_y_get, _trottersuzuki.Lattice_dim_y_set)
    __swig_setmethods__["global_no_halo_dim_x"] = _trottersuzuki.Lattice_global_no_halo_dim_x_set
    __swig_getmethods__["global_no_halo_dim_x"] = _trottersuzuki.Lattice_global_no_halo_dim_x_get
    if _newclass:
        global_no_halo_dim_x = _swig_property(_trottersuzuki.Lattice_global_no_halo_dim_x_get, _trottersuzuki.Lattice_global_no_halo_dim_x_set)
    __swig_setmethods__["global_no_halo_dim_y"] = _trottersuzuki.Lattice_global_no_halo_dim_y_set
    __swig_getmethods__["global_no_halo_dim_y"] = _trottersuzuki.Lattice_global_no_halo_dim_y_get
    if _newclass:
        global_no_halo_dim_y = _swig_property(_trottersuzuki.Lattice_global_no_halo_dim_y_get, _trottersuzuki.Lattice_global_no_halo_dim_y_set)
    __swig_setmethods__["start_x"] = _trottersuzuki.Lattice_start_x_set
    __swig_getmethods__["start_x"] = _trottersuzuki.Lattice_start_x_get
    if _newclass:
        start_x = _swig_property(_trottersuzuki.Lattice_start_x_get, _trottersuzuki.Lattice_start_x_set)
    __swig_setmethods__["start_y"] = _trottersuzuki.Lattice_start_y_set
    __swig_getmethods__["start_y"] = _trottersuzuki.Lattice_start_y_get
    if _newclass:
        start_y = _swig_property(_trottersuzuki.Lattice_start_y_get, _trottersuzuki.Lattice_start_y_set)
    __swig_setmethods__["coordinate_system"] = _trottersuzuki.Lattice_coordinate_system_set
    __swig_getmethods__["coordinate_system"] = _trottersuzuki.Lattice_coordinate_system_get
    if _newclass:
        coordinate_system = _swig_property(_trottersuzuki.Lattice_coordinate_system_get, _trottersuzuki.Lattice_coordinate_system_set)

    def __init__(self):
        this = _trottersuzuki.new_Lattice()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Lattice
    __del__ = lambda self: None
Lattice_swigregister = _trottersuzuki.Lattice_swigregister
Lattice_swigregister(Lattice)

class Lattice1D(Lattice):
    __swig_setmethods__ = {}
    for _s in [Lattice]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice1D, name, value)
    __swig_getmethods__ = {}
    for _s in [Lattice]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice1D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _trottersuzuki.new_Lattice1D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Lattice1D
    __del__ = lambda self: None
Lattice1D_swigregister = _trottersuzuki.Lattice1D_swigregister
Lattice1D_swigregister(Lattice1D)

class Lattice2D(Lattice):
    """



    """

    __swig_setmethods__ = {}
    for _s in [Lattice]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Lattice]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice2D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Lattice2D constructor.  

        Parameters
        ----------
        * `dim_x` : integer
            Linear dimension of the squared lattice in the x direction.
        * `length_x` : float
            Physical length of the lattice's side in the x direction.
        * `dim_y` : integer,optional (default: equal to to dim_x)
            Linear dimension of the squared lattice in the y direction.
        * `length_y` : float,optional (default: equal to to length_x)
            Physical length of the lattice's side in the y direction.
        * `periodic_x_axis` : bool,optional (default: False)
            Boundary condition along the x axis (false=closed, true=periodic).  
        * `periodic_y_axis` : bool,optional (default: False) 
            Boundary condition along the y axis (false=closed, true=periodic).

        Returns
        -------
        * `Lattice2D` : Lattice2D object 
            Define the geometry of the simulation.

        Notes
        -----
        The lattice created is squared.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> # Generate a 200x200 Lattice2D with physical dimensions of 30x30
            >>> # and closed boundary conditions.
            >>> grid = ts.Lattice2D(200, 30.)


        """
        this = _trottersuzuki.new_Lattice2D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Lattice2D
    __del__ = lambda self: None
Lattice2D_swigregister = _trottersuzuki.Lattice2D_swigregister
Lattice2D_swigregister(Lattice2D)

class State(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, State, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, State, name)
    __repr__ = _swig_repr
    __swig_setmethods__["grid"] = _trottersuzuki.State_grid_set
    __swig_getmethods__["grid"] = _trottersuzuki.State_grid_get
    if _newclass:
        grid = _swig_property(_trottersuzuki.State_grid_get, _trottersuzuki.State_grid_set)

    def __init__(self, *args):
        """


        Create a quantum state.  

        Parameters
        ----------
        * `grid` : Lattice object  
            Define the geometry of the simulation.

        Returns
        -------
        * `state` : State object
            Quantum state.

        Notes
        -----
        It may be used to copy a quantum state.

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state with a gaussian wave function
            >>> state2 = ts.State(state)  # Copy state into state2

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> def wave_function(x,y):  # Define a flat wave function
            >>>     return 1.
            >>> state = ts.State(grid)  # Create the system's state
            >>> state.ini_state(wave_function)  # Initialize the wave function of the state

        """
        this = _trottersuzuki.new_State(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_State
    __del__ = lambda self: None

    def init_state_matrix(self, state_real, state_imag):
        return _trottersuzuki.State_init_state_matrix(self, state_real, state_imag)

    def loadtxt(self, file_name):
        """


        Load the wave function from a file.

        Parameters
        ----------
        * `file_name` : string
              Name of the file to be written.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state
            >>> state.write_to_file('wave_function.txt')  # Write to a file the wave function
            >>> state2 = ts.State(grid)  # Create a quantum state
            >>> state2.loadtxt('wave_function.txt')  # Load the wave function

        """
        return _trottersuzuki.State_loadtxt(self, file_name)


    def imprint_matrix(self, state_real, state_imag):
        return _trottersuzuki.State_imprint_matrix(self, state_real, state_imag)

    def get_particle_density(self):
        """


        Return a matrix storing the squared norm of the wave function.

        Returns
        -------
        * `particle_density` : numpy matrix
            Particle density of the state :math:`|\psi(x,y)|^2` 

        """
        return _trottersuzuki.State_get_particle_density(self)


    def get_phase(self):
        """


        Return a matrix of the wave function's phase.

        Returns
        -------
        * `get_phase` : numpy matrix
            Matrix of the wave function's phase :math:`\phi(x,y) = \log(\psi(x,y))`

        """
        return _trottersuzuki.State_get_phase(self)


    def get_expected_value(self, _operator):
        return _trottersuzuki.State_get_expected_value(self, _operator)

    def get_squared_norm(self):
        """


        Return the squared norm of the quantum state.

        Returns
        -------
        * `squared_norm` : float
              Squared norm of the quantum state.

        """
        return _trottersuzuki.State_get_squared_norm(self)


    def get_mean_x(self):
        """


        Return the expected value of the :math:`X` operator.  

        Returns
        -------
        * `mean_x` : float
              Expected value of the :math:`X` operator. 

        """
        return _trottersuzuki.State_get_mean_x(self)


    def get_mean_xx(self):
        """


        Return the expected value of the :math:`X^2` operator.

        Returns
        -------
        * `mean_xx` : float
              Expected value of the :math:`X^2` operator.   

        """
        return _trottersuzuki.State_get_mean_xx(self)


    def get_mean_y(self):
        """


        Return the expected value of the :math:`Y` operator.

        Returns
        -------
        * `mean_y` : float
              Expected value of the :math:`Y` operator.   

        """
        return _trottersuzuki.State_get_mean_y(self)


    def get_mean_yy(self):
        """


        Return the expected value of the :math:`Y^2` operator.

        Returns
        -------
        * `mean_yy` : float
              Expected value of the :math:`Y^2` operator.

        """
        return _trottersuzuki.State_get_mean_yy(self)


    def get_mean_px(self):
        """


        Return the expected value of the :math:`P_x` operator.  

        Returns
        -------
        * `mean_px` : float
              Expected value of the :math:`P_x` operator.

        """
        return _trottersuzuki.State_get_mean_px(self)


    def get_mean_pxpx(self):
        """


        Return the expected value of the :math:`P_x^2` operator.

        Returns
        -------
        * `mean_pxpx` : float
              Expected value of the :math:`P_x^2` operator.  

        """
        return _trottersuzuki.State_get_mean_pxpx(self)


    def get_mean_py(self):
        """


        Return the expected value of the :math:`P_y` operator.  

        Returns
        -------
        * `mean_py` : float
              Expected value of the :math:`P_y` operator.

        """
        return _trottersuzuki.State_get_mean_py(self)


    def get_mean_pypy(self):
        """


        Return the expected value of the :math:`P_y^2` operator.  

        Returns
        -------
        * `mean_pypy` : float
              Expected value of the :math:`P_y^2` operator. 

        """
        return _trottersuzuki.State_get_mean_pypy(self)


    def get_mean_angular_momentum(self):
        """


        Return the expected value of the :math:`L_z^2` operator.  

        Returns
        -------
        * `mean_angular_momentum` : float
              Expected value of the :math:`L_z^2` operator. 

        """
        return _trottersuzuki.State_get_mean_angular_momentum(self)


    def write_to_file(self, fileprefix):
        """


        Write to a file the wave function.  

        Parameters
        ----------
        * `file_name` : string
              Name of the file to be written. 

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state
            >>> state.write_to_file('wave_function.txt')  # Write to a file the wave function
            >>> state2 = ts.State(grid)  # Create a quantum state
            >>> state2.loadtxt('wave_function.txt')  # Load the wave function

        """
        return _trottersuzuki.State_write_to_file(self, fileprefix)


    def write_particle_density(self, fileprefix):
        """


        Write to a file the particle density matrix of the wave function.

        Parameters
        ----------
        * `file_name` : string
            Name of the file.  

        """
        return _trottersuzuki.State_write_particle_density(self, fileprefix)


    def write_phase(self, fileprefix):
        """


        Write to a file the phase of the wave function. 

        Parameters
        ----------
        * `file_name` : string
            Name of the file.

        """
        return _trottersuzuki.State_write_phase(self, fileprefix)

    __swig_setmethods__["expected_values_updated"] = _trottersuzuki.State_expected_values_updated_set
    __swig_getmethods__["expected_values_updated"] = _trottersuzuki.State_expected_values_updated_get
    if _newclass:
        expected_values_updated = _swig_property(_trottersuzuki.State_expected_values_updated_get, _trottersuzuki.State_expected_values_updated_set)
State_swigregister = _trottersuzuki.State_swigregister
State_swigregister(State)

class ExponentialState(State):
    """



    """

    __swig_setmethods__ = {}
    for _s in [State]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExponentialState, name, value)
    __swig_getmethods__ = {}
    for _s in [State]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExponentialState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Construct the quantum state with exponential like wave function.  

        Parameters
        ----------
        * `grid` : Lattice2D object 
            Defines the geometry of the simulation.  
        * `n_x` : integer,optional (default: 1)
            First quantum number.  
        * `n_y` : integer,optional (default: 1)
            Second quantum number.  
        * `norm` : float,optional (default: 1)
            Squared norm of the quantum state.  
        * `phase` : float,optional (default: 0)
            Relative phase of the wave function. 

        Returns
        -------
        * `ExponentialState` : State object. 
            Quantum state with exponential like wave function. The wave function is give by:


            .. math:: \psi(x,y) = \sqrt{N}/L \mathrm{e}^{i 2 \pi (n_x x + n_y y) / L} \mathrm{e}^{i \phi}

            being :math:`N` the norm of the state, :math:`L` 
            the length of the lattice edge, :math:`n_x` and :math:`n_y` the quantum numbers 
            and :math:`\phi` the relative phase.

        Notes
        -----
        The geometry of the simulation has to have periodic boundary condition 
        to use Exponential state as initial state of a real time evolution. 
        Indeed, the wave function is not null at the edges of the space.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(300, 30., True, True)  # Define the simulation's geometry
            >>> state = ts.ExponentialState(grid, 2, 1)  # Create the system's state

        """
        this = _trottersuzuki.new_ExponentialState(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_ExponentialState
    __del__ = lambda self: None
ExponentialState_swigregister = _trottersuzuki.ExponentialState_swigregister
ExponentialState_swigregister(ExponentialState)

class GaussianState(State):
    """



    """

    __swig_setmethods__ = {}
    for _s in [State]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianState, name, value)
    __swig_getmethods__ = {}
    for _s in [State]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Construct the quantum state with gaussian like wave function.  

        Parameters
        ----------
        * `grid` : Lattice2D object 
            Defines the geometry of the simulation.  
        * `omega_x` : float
            Inverse of the variance along x-axis.  
        * `omega_y` : float, optional (default: omega_x) 
            Inverse of the variance along y-axis.
        * `mean_x` : float, optional (default: 0)
            X coordinate of the gaussian function's peak.  
        * `mean_y` : float, optional (default: 0)
            Y coordinate of the gaussian function's peak.  
        * `norm` : float, optional (default: 1) 
            Squared norm of the state.  
        * `phase` : float, optional (default: 0) 
            Relative phase of the wave function. 

        Returns
        -------
        * `GaussianState` : State object. 
            Quantum state with gaussian like wave function. The wave function is given by:


            .. math:: \psi(x,y) = (N/\pi)^{1/2} (\omega_x \omega_y)^{1/4} \mathrm{e}^{-(\omega_x(x-\mu_x)^2 + \omega_y(y-\mu_y)^2)/2} \mathrm{e}^{i \phi}

            being :math:`N` the norm of the state, :math:`\omega_x` and :math:`\omega_y` 
            the inverse of the variances, :math:`\mu_x` and :math:`\mu_y` the coordinates of the
            function's peak and :math:`\phi` the relative phase.

        Notes
        -----
        The physical dimensions of the Lattice2D have to be enough to ensure that 
        the wave function is almost zero at the edges.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(300, 30.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 2.)  # Create the system's state

        """
        this = _trottersuzuki.new_GaussianState(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_GaussianState
    __del__ = lambda self: None
GaussianState_swigregister = _trottersuzuki.GaussianState_swigregister
GaussianState_swigregister(GaussianState)

class SinusoidState(State):
    """



    """

    __swig_setmethods__ = {}
    for _s in [State]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SinusoidState, name, value)
    __swig_getmethods__ = {}
    for _s in [State]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SinusoidState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Construct the quantum state with sinusoidal like wave function.  

        Parameters
        ----------
        * `grid` : Lattice2D object  
            Define the geometry of the simulation.  
        * `n_x` : integer, optional (default: 1) 
            First quantum number.  
        * `n_y` : integer, optional (default: 1)  
            Second quantum number.  
        * `norm` : float, optional (default: 1)  
            Squared norm of the quantum state.  
        * `phase` : float, optional (default: 1) 
            Relative phase of the wave function.

        Returns
        -------
        * `SinusoidState` : State object. 
            Quantum state with sinusoidal like wave function. The wave function is given by:

            .. math:: \psi(x,y) = 2\sqrt{N}/L \sin(2\pi n_x x / L) \sin(2\pi n_y y / L) \mathrm{e}^{(i \phi)}

            being :math:`N` the norm of the state, :math:`L` 
            the length of the lattice edge, :math:`n_x` and :math:`n_y` the quantum numbers 
            and :math:`\phi` the relative phase.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(300, 30., True, True)  # Define the simulation's geometry
            >>> state = ts.SinusoidState(grid, 2, 0)  # Create the system's state


        """
        this = _trottersuzuki.new_SinusoidState(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_SinusoidState
    __del__ = lambda self: None
SinusoidState_swigregister = _trottersuzuki.SinusoidState_swigregister
SinusoidState_swigregister(SinusoidState)

class BesselState(State):
    __swig_setmethods__ = {}
    for _s in [State]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BesselState, name, value)
    __swig_getmethods__ = {}
    for _s in [State]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BesselState, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _trottersuzuki.new_BesselState(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_BesselState
    __del__ = lambda self: None
BesselState_swigregister = _trottersuzuki.BesselState_swigregister
BesselState_swigregister(BesselState)

class Potential(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Potential, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Potential, name)
    __repr__ = _swig_repr
    __swig_setmethods__["grid"] = _trottersuzuki.Potential_grid_set
    __swig_getmethods__["grid"] = _trottersuzuki.Potential_grid_get
    if _newclass:
        grid = _swig_property(_trottersuzuki.Potential_grid_get, _trottersuzuki.Potential_grid_set)
    __swig_setmethods__["matrix"] = _trottersuzuki.Potential_matrix_set
    __swig_getmethods__["matrix"] = _trottersuzuki.Potential_matrix_get
    if _newclass:
        matrix = _swig_property(_trottersuzuki.Potential_matrix_get, _trottersuzuki.Potential_matrix_set)

    def __init__(self, *args):
        """


        Construct the external potential.  

        Parameters
        ----------
        * `grid` : Lattice object 
            Define the geometry of the simulation.  

        Returns
        -------
        * `Potential` : Potential object 
            Create external potential.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> # Define a constant external potential
            >>> def external_potential_function(x,y):
            >>>     return 1.
            >>> potential = ts.Potential(grid)  # Create the external potential
            >>> potential.init_potential(external_potential_function)  # Initialize the external potential

        """
        this = _trottersuzuki.new_Potential(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Potential
    __del__ = lambda self: None

    def init_potential_matrix(self, _potential):
        return _trottersuzuki.Potential_init_potential_matrix(self, _potential)

    def get_value(self, x, y):
        """


        Get the value at the lattice's coordinate (x,y).

        Returns
        -------
        * `value` : float
            Value of the external potential.

        """
        return _trottersuzuki.Potential_get_value(self, x, y)


    def update(self, t):
        """


        Update the potential matrix at time t.  

        """
        return _trottersuzuki.Potential_update(self, t)

    __swig_setmethods__["updated_potential_matrix"] = _trottersuzuki.Potential_updated_potential_matrix_set
    __swig_getmethods__["updated_potential_matrix"] = _trottersuzuki.Potential_updated_potential_matrix_get
    if _newclass:
        updated_potential_matrix = _swig_property(_trottersuzuki.Potential_updated_potential_matrix_get, _trottersuzuki.Potential_updated_potential_matrix_set)
Potential_swigregister = _trottersuzuki.Potential_swigregister
Potential_swigregister(Potential)

class HarmonicPotential(Potential):
    """



    """

    __swig_setmethods__ = {}
    for _s in [Potential]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HarmonicPotential, name, value)
    __swig_getmethods__ = {}
    for _s in [Potential]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HarmonicPotential, name)
    __repr__ = _swig_repr

    def __init__(self, _grid, _omegax, _omegay, _mass=1., _mean_x=0., _mean_y=0.):
        """


        Construct the harmonic external potential.  

        Parameters
        ----------
        * `grid` : Lattice2D object  
            Define the geometry of the simulation.  
        * `omegax` : float
            Frequency along x-axis.  
        * `omegay` : float 
            Frequency along y-axis.  
        * `mass` : float,optional (default: 1.) 
            Mass of the particle.  
        * `mean_x` : float,optional (default: 0.) 
            Minimum of the potential along x axis.  
        * `mean_y` : float,optional (default: 0.) 
            Minimum of the potential along y axis.  

        Returns
        -------
        * `HarmonicPotential` : Potential object 
            Harmonic external potential.

        Notes
        -----
        External potential function:


        .. math:: V(x,y) = 1/2 m (\omega_x^2  x^2 + \omega_y^2 y^2)

        being :math:`m` the particle mass, :math:`\omega_x` and :math:`\omega_y` the potential frequencies.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 10)  # Define the simulation's geometry
            >>> potential = ts.HarmonicPotential(grid, 2., 1.)  # Create an harmonic external potential


        """
        this = _trottersuzuki.new_HarmonicPotential(_grid, _omegax, _omegay, _mass, _mean_x, _mean_y)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_HarmonicPotential
    __del__ = lambda self: None

    def get_value(self, x, y):
        """


        Return the value of the external potential at coordinate (x,y)  

        """
        return _trottersuzuki.HarmonicPotential_get_value(self, x, y)

HarmonicPotential_swigregister = _trottersuzuki.HarmonicPotential_swigregister
HarmonicPotential_swigregister(HarmonicPotential)

class Hamiltonian(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hamiltonian, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hamiltonian, name)
    __repr__ = _swig_repr
    __swig_setmethods__["potential"] = _trottersuzuki.Hamiltonian_potential_set
    __swig_getmethods__["potential"] = _trottersuzuki.Hamiltonian_potential_get
    if _newclass:
        potential = _swig_property(_trottersuzuki.Hamiltonian_potential_get, _trottersuzuki.Hamiltonian_potential_set)
    __swig_setmethods__["mass"] = _trottersuzuki.Hamiltonian_mass_set
    __swig_getmethods__["mass"] = _trottersuzuki.Hamiltonian_mass_get
    if _newclass:
        mass = _swig_property(_trottersuzuki.Hamiltonian_mass_get, _trottersuzuki.Hamiltonian_mass_set)
    __swig_setmethods__["coupling_a"] = _trottersuzuki.Hamiltonian_coupling_a_set
    __swig_getmethods__["coupling_a"] = _trottersuzuki.Hamiltonian_coupling_a_get
    if _newclass:
        coupling_a = _swig_property(_trottersuzuki.Hamiltonian_coupling_a_get, _trottersuzuki.Hamiltonian_coupling_a_set)
    __swig_setmethods__["LeeHuangYang_coupling_a"] = _trottersuzuki.Hamiltonian_LeeHuangYang_coupling_a_set
    __swig_getmethods__["LeeHuangYang_coupling_a"] = _trottersuzuki.Hamiltonian_LeeHuangYang_coupling_a_get
    if _newclass:
        LeeHuangYang_coupling_a = _swig_property(_trottersuzuki.Hamiltonian_LeeHuangYang_coupling_a_get, _trottersuzuki.Hamiltonian_LeeHuangYang_coupling_a_set)
    __swig_setmethods__["angular_velocity"] = _trottersuzuki.Hamiltonian_angular_velocity_set
    __swig_getmethods__["angular_velocity"] = _trottersuzuki.Hamiltonian_angular_velocity_get
    if _newclass:
        angular_velocity = _swig_property(_trottersuzuki.Hamiltonian_angular_velocity_get, _trottersuzuki.Hamiltonian_angular_velocity_set)
    __swig_setmethods__["rot_coord_x"] = _trottersuzuki.Hamiltonian_rot_coord_x_set
    __swig_getmethods__["rot_coord_x"] = _trottersuzuki.Hamiltonian_rot_coord_x_get
    if _newclass:
        rot_coord_x = _swig_property(_trottersuzuki.Hamiltonian_rot_coord_x_get, _trottersuzuki.Hamiltonian_rot_coord_x_set)
    __swig_setmethods__["rot_coord_y"] = _trottersuzuki.Hamiltonian_rot_coord_y_set
    __swig_getmethods__["rot_coord_y"] = _trottersuzuki.Hamiltonian_rot_coord_y_get
    if _newclass:
        rot_coord_y = _swig_property(_trottersuzuki.Hamiltonian_rot_coord_y_get, _trottersuzuki.Hamiltonian_rot_coord_y_set)

    def __init__(self, _grid, _potential=None, _mass=1., _coupling_a=0., LeeHuangYang_coupling_a=0., _angular_velocity=0., _rot_coord_x=0, _rot_coord_y=0):
        """


        Construct the Hamiltonian of a single component system.  

        Parameters
        ----------
        * `grid` : Lattice object 
            Define the geometry of the simulation.  
        * `potential` : Potential object 
            Define the external potential of the Hamiltonian (:math:`V`).  
        * `mass` : float,optional (default: 1.) 
            Mass of the particle (:math:`m`).  
        * `coupling` : float,optional (default: 0.) 
            Coupling constant of intra-particle interaction (:math:`g`).  
        * `angular_velocity` : float,optional (default: 0.) 
            The frame of reference rotates with this angular velocity (:math:`\omega`).  
        * `rot_coord_x` : float,optional (default: 0.) 
            X coordinate of the center of rotation.  
        * `rot_coord_y` : float,optional (default: 0.)
            Y coordinate of the center of rotation.

        Returns
        -------
        * `Hamiltonian` : Hamiltonian object
            Hamiltonian of the system to be simulated: 

            .. math:: H(x,y) = 1/(2m)(P_x^2 + P_y^2)  + V(x,y) + g |\psi(x,y)|^2 + \omega L_z

            being :math:`m` the particle mass, :math:`V(x,y)` the external potential, 
            :math:`g` the coupling constant of intra-particle interaction, :math:`\omega` 
            the angular velocity of the frame of reference  and :math:`L_z` the angular momentum operator along the z-axis.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create an harmonic external potential
            >>> hamiltonian = ts.Hamiltonian(grid, potential)  # Create the Hamiltonian of an harmonic oscillator

        """
        this = _trottersuzuki.new_Hamiltonian(_grid, _potential, _mass, _coupling_a, LeeHuangYang_coupling_a, _angular_velocity, _rot_coord_x, _rot_coord_y)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Hamiltonian
    __del__ = lambda self: None
Hamiltonian_swigregister = _trottersuzuki.Hamiltonian_swigregister
Hamiltonian_swigregister(Hamiltonian)

class Hamiltonian2Component(Hamiltonian):
    """



    """

    __swig_setmethods__ = {}
    for _s in [Hamiltonian]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hamiltonian2Component, name, value)
    __swig_getmethods__ = {}
    for _s in [Hamiltonian]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hamiltonian2Component, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mass_b"] = _trottersuzuki.Hamiltonian2Component_mass_b_set
    __swig_getmethods__["mass_b"] = _trottersuzuki.Hamiltonian2Component_mass_b_get
    if _newclass:
        mass_b = _swig_property(_trottersuzuki.Hamiltonian2Component_mass_b_get, _trottersuzuki.Hamiltonian2Component_mass_b_set)
    __swig_setmethods__["coupling_ab"] = _trottersuzuki.Hamiltonian2Component_coupling_ab_set
    __swig_getmethods__["coupling_ab"] = _trottersuzuki.Hamiltonian2Component_coupling_ab_get
    if _newclass:
        coupling_ab = _swig_property(_trottersuzuki.Hamiltonian2Component_coupling_ab_get, _trottersuzuki.Hamiltonian2Component_coupling_ab_set)
    __swig_setmethods__["coupling_b"] = _trottersuzuki.Hamiltonian2Component_coupling_b_set
    __swig_getmethods__["coupling_b"] = _trottersuzuki.Hamiltonian2Component_coupling_b_get
    if _newclass:
        coupling_b = _swig_property(_trottersuzuki.Hamiltonian2Component_coupling_b_get, _trottersuzuki.Hamiltonian2Component_coupling_b_set)
    __swig_setmethods__["omega_r"] = _trottersuzuki.Hamiltonian2Component_omega_r_set
    __swig_getmethods__["omega_r"] = _trottersuzuki.Hamiltonian2Component_omega_r_get
    if _newclass:
        omega_r = _swig_property(_trottersuzuki.Hamiltonian2Component_omega_r_get, _trottersuzuki.Hamiltonian2Component_omega_r_set)
    __swig_setmethods__["omega_i"] = _trottersuzuki.Hamiltonian2Component_omega_i_set
    __swig_getmethods__["omega_i"] = _trottersuzuki.Hamiltonian2Component_omega_i_get
    if _newclass:
        omega_i = _swig_property(_trottersuzuki.Hamiltonian2Component_omega_i_get, _trottersuzuki.Hamiltonian2Component_omega_i_set)
    __swig_setmethods__["potential_b"] = _trottersuzuki.Hamiltonian2Component_potential_b_set
    __swig_getmethods__["potential_b"] = _trottersuzuki.Hamiltonian2Component_potential_b_get
    if _newclass:
        potential_b = _swig_property(_trottersuzuki.Hamiltonian2Component_potential_b_get, _trottersuzuki.Hamiltonian2Component_potential_b_set)

    def __init__(self, _grid, _potential=None, _potential_b=None, _mass=1., _mass_b=1., _coupling_a=0., coupling_ab=0., _coupling_b=0., _omega_r=0, _omega_i=0, _angular_velocity=0., _rot_coord_x=0, _rot_coord_y=0):
        """


        Construct the Hamiltonian of a two component system.  

        Parameters
        ----------
        * `grid` : Lattice object  
            Define the geometry of the simulation.  
        * `potential_1` : Potential object 
            External potential to which the first state is subjected (:math:`V_1`).  
        * `potential_2` : Potential object 
            External potential to which the second state is subjected (:math:`V_2`).  
        * `mass_1` : float,optional (default: 1.) 
            Mass of the first-component's particles (:math:`m_1`).  
        * `mass_2` : float,optional (default: 1.) 
            Mass of the second-component's particles (:math:`m_2`).  
        * `coupling_1` : float,optional (default: 0.) 
            Coupling constant of intra-particle interaction for the first component (:math:`g_1`).  
        * `coupling_12` : float,optional (default: 0.) 
            Coupling constant of inter-particle interaction between the two components (:math:`g_{12}`).  
        * `coupling_2` : float,optional (default: 0.) 
            Coupling constant of intra-particle interaction for the second component (:math:`g_2`).  
        * `omega_r` : float,optional (default: 0.) 
            Real part of the Rabi coupling (:math:`\mathrm{Re}(\Omega)`).  
        * `omega_i` : float,optional (default: 0.) 
            Imaginary part of the Rabi coupling (:math:`\mathrm{Im}(\Omega)`).  
        * `angular_velocity` : float,optional (default: 0.) 
            The frame of reference rotates with this angular velocity (:math:`\omega`).  
        * `rot_coord_x` : float,optional (default: 0.) 
            X coordinate of the center of rotation.  
        * `rot_coord_y` : float,optional (default: 0.) 
            Y coordinate of the center of rotation.  

        Returns
        -------
        * `Hamiltonian2Component` : Hamiltonian2Component object 
            Hamiltonian of the two-component system to be simulated.

            .. math::

               H(x,y)(\psi_1,\psi_2) &= 


               &(1/(2m_1)(P_x^2 + P_y^2) + V_1(x,y) + g_1 |\psi_1(x,y)|^2 + g_{12} |\psi_2(x,y)|^2 + \omega L_z)\psi_1 + \Omega \psi_2 /2 

               &(1/(2m_2)(P_x^2 + P_y^2) + V_2(x,y) + g_2 |\psi_2(x,y)|^2 + g_{12} |\psi_1(x,y)|^2 + \omega L_z)\psi_2 + \Omega \psi_1 /2


            being, for the i-th component, :math:`m_i` the particle mass, :math:`V_i(x,y)` the external potential, 
            :math:`g_i` the coupling constant of intra-particle interaction; 
            :math:`g_{12}` the coupling constant of inter-particle interaction 
            :math:`\omega` the angular velocity of the frame of reference, :math:`L_z` the angular momentum operator along the z-axis 
            and :math:`\Omega` the Rabi coupling.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create an harmonic external potential
            >>> hamiltonian = ts.Hamiltonian2Component(grid, potential, potential)  # Create the Hamiltonian of an harmonic oscillator for a two-component system

        """
        this = _trottersuzuki.new_Hamiltonian2Component(_grid, _potential, _potential_b, _mass, _mass_b, _coupling_a, coupling_ab, _coupling_b, _omega_r, _omega_i, _angular_velocity, _rot_coord_x, _rot_coord_y)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Hamiltonian2Component
    __del__ = lambda self: None
Hamiltonian2Component_swigregister = _trottersuzuki.Hamiltonian2Component_swigregister
Hamiltonian2Component_swigregister(Hamiltonian2Component)

class Solver(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Solver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Solver, name)
    __repr__ = _swig_repr
    __swig_setmethods__["grid"] = _trottersuzuki.Solver_grid_set
    __swig_getmethods__["grid"] = _trottersuzuki.Solver_grid_get
    if _newclass:
        grid = _swig_property(_trottersuzuki.Solver_grid_get, _trottersuzuki.Solver_grid_set)
    __swig_setmethods__["state"] = _trottersuzuki.Solver_state_set
    __swig_getmethods__["state"] = _trottersuzuki.Solver_state_get
    if _newclass:
        state = _swig_property(_trottersuzuki.Solver_state_get, _trottersuzuki.Solver_state_set)
    __swig_setmethods__["state_b"] = _trottersuzuki.Solver_state_b_set
    __swig_getmethods__["state_b"] = _trottersuzuki.Solver_state_b_get
    if _newclass:
        state_b = _swig_property(_trottersuzuki.Solver_state_b_get, _trottersuzuki.Solver_state_b_set)
    __swig_setmethods__["hamiltonian"] = _trottersuzuki.Solver_hamiltonian_set
    __swig_getmethods__["hamiltonian"] = _trottersuzuki.Solver_hamiltonian_get
    if _newclass:
        hamiltonian = _swig_property(_trottersuzuki.Solver_hamiltonian_get, _trottersuzuki.Solver_hamiltonian_set)
    __swig_setmethods__["current_evolution_time"] = _trottersuzuki.Solver_current_evolution_time_set
    __swig_getmethods__["current_evolution_time"] = _trottersuzuki.Solver_current_evolution_time_get
    if _newclass:
        current_evolution_time = _swig_property(_trottersuzuki.Solver_current_evolution_time_get, _trottersuzuki.Solver_current_evolution_time_set)

    def __init__(self, *args):
        """


        Construct the Solver object for a two-component system.  

        Parameters
        ----------
        * `grid` : Lattice object  
            Define the geometry of the simulation.
        * `state1` : State object
            First component's state of the system.  
        * `state2` : State object 
            Second component's state of the system.  
        * `hamiltonian` : Hamiltonian object
            Hamiltonian of the two-component system.  
        * `delta_t` : float
            A single evolution iteration, evolves the state for this time.  
        * `kernel_type` : string,optional (default: 'cpu') 
            Which kernel to use (either cpu or gpu).  

        Returns
        -------
        * `Solver` : Solver object  
            Solver object for the simulation of a two-component system.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state_1 = ts.GaussianState(grid, 1.)  # Create first-component system's state
            >>> state_2 = ts.GaussianState(grid, 1.)  # Create second-component system's state
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create harmonic potential
            >>> hamiltonian = ts.Hamiltonian2Component(grid, potential, potential)  # Create an harmonic oscillator Hamiltonian
            >>> solver = ts.Solver(grid, state_1, state_2, hamiltonian, 1e-2)  # Create the solver


        """
        this = _trottersuzuki.new_Solver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _trottersuzuki.delete_Solver
    __del__ = lambda self: None

    def evolve(self, iterations, imag_time=False):
        """


        Evolve the state of the system.

        Parameters
        ----------
        * `iterations` : integer 
            Number of iterations.
        * `imag_time` : bool,optional (default: False)  
            Whether to perform imaginary time evolution (True) or real time evolution (False).    

        Notes
        -----

        The norm of the state is preserved both in real-time and in imaginary-time evolution.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create harmonic potential
            >>> hamiltonian = ts.Hamiltonian(grid, potential)  # Create a harmonic oscillator Hamiltonian
            >>> solver = ts.Solver(grid, state, hamiltonian, 1e-2)  # Create the solver
            >>> solver.evolve(1000)  # perform 1000 iteration in real time evolution

        """
        return _trottersuzuki.Solver_evolve(self, iterations, imag_time)


    def update_parameters(self):
        """


        Notify the solver if any parameter changed in the Hamiltonian


        """
        return _trottersuzuki.Solver_update_parameters(self)


    def get_total_energy(self):
        """


        Get the total energy of the system.

        Returns
        -------
        * `get_total_energy` : float
            Total energy of the system.  

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create harmonic potential
            >>> hamiltonian = ts.Hamiltonian(grid, potential)  # Create a harmonic oscillator Hamiltonian
            >>> solver = ts.Solver(grid, state, hamiltonian, 1e-2)  # Create the solver
            >>> solver.get_total_energy()  # Get the total energy
            1

        """
        return _trottersuzuki.Solver_get_total_energy(self)


    def get_squared_norm(self, which=3):
        """


        Get the squared norm of the state (default: total wave-function).

        Parameters
        ----------
        * `which` : integer,optional (default: 3)
            Which squared state norm to return: total system (default, which=3), first component (which=1), second component (which=2). 

        Returns
        -------
        * `get_squared_norm` : float
            Squared norm of the state.   

        """
        return _trottersuzuki.Solver_get_squared_norm(self, which)


    def get_kinetic_energy(self, which=3):
        """


        Get the kinetic energy of the system.

        Parameters
        ----------
        * `which` : integer,optional (default: 3)
            Which kinetic energy to return: total system (default, which=3), first component (which=1), second component (which=2). 

        Returns
        -------
        * `get_kinetic_energy` : float
            kinetic energy of the system.

        Example
        -------

            >>> import trottersuzuki as ts  # import the module
            >>> grid = ts.Lattice2D(200, 20.)  # Define the simulation's geometry
            >>> state = ts.GaussianState(grid, 1.)  # Create the system's state
            >>> potential = ts.HarmonicPotential(grid, 1., 1.)  # Create harmonic potential
            >>> hamiltonian = ts.Hamiltonian(grid, potential)  # Create a harmonic oscillator Hamiltonian
            >>> solver = ts.Solver(grid, state, hamiltonian, 1e-2)  # Create the solver
            >>> solver.get_kinetic_energy()  # Get the kinetic energy
            0.5

        """
        return _trottersuzuki.Solver_get_kinetic_energy(self, which)


    def get_potential_energy(self, which=3):
        """


        Get the potential energy of the system.  

        Parameters
        ----------
        * `which` : integer,optional (default: 3)
            Which potential energy to return: total system (default, which=3), first component (which=1), second component (which=2). 

        Returns
        -------
        * `get_potential_energy` : float
            Potential energy of the system.

        """
        return _trottersuzuki.Solver_get_potential_energy(self, which)


    def get_rotational_energy(self, which=3):
        """


        Get the rotational energy of the system.

        Parameters
        ----------
        * `which` : integer,optional (default: 3)
            Which rotational energy to return: total system (default, which=3), first component (which=1), second component (which=2). 

        Returns
        -------
        * `get_rotational_energy` : float
            Rotational energy of the system.

        """
        return _trottersuzuki.Solver_get_rotational_energy(self, which)


    def get_intra_species_energy(self, which=3):
        """


        Get the intra-particles interaction energy of the system.  

        Parameters
        ----------
        * `which` : integer,optional (default: 3)
            Which intra-particles interaction energy to return: total system (default, which=3), first component (which=1), second component (which=2). 

        Returns
        -------
        * `get_intra_species_energy` : float
            Intra-particles interaction energy of the system. 

        """
        return _trottersuzuki.Solver_get_intra_species_energy(self, which)


    def get_LeeHuangYang_energy(self):
        return _trottersuzuki.Solver_get_LeeHuangYang_energy(self)

    def get_inter_species_energy(self):
        """


        Get the inter-particles interaction energy of the system.  

        Returns
        -------
        * `get_inter_species_energy` : float
            Inter-particles interaction energy of the system. 

        """
        return _trottersuzuki.Solver_get_inter_species_energy(self)


    def get_rabi_energy(self):
        """


        Get the Rabi energy of the system.

        Returns
        -------
        * `get_rabi_energy` : float
            Rabi energy of the system.  

        """
        return _trottersuzuki.Solver_get_rabi_energy(self)


    def set_exp_potential(self, exp_pot_real, exp_pot_imag, which):
        return _trottersuzuki.Solver_set_exp_potential(self, exp_pot_real, exp_pot_imag, which)
Solver_swigregister = _trottersuzuki.Solver_swigregister
Solver_swigregister(Solver)

# This file is compatible with both classic and new-style classes.


